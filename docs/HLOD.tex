\subsection{HLOD}
\label{subsec:HLOD}
Davis \cite{Davis} used a quad tree data structure to check what information has to be rendered on the screen. The leaf nodes contains the most detailed models. The non-leafs contains the combined area of it's childeren, but have a simplified model of the data. With such a data structure it is possible to render further away with less detail.

\subsubsection{Generating HLOD}
Algorithm \ref{alg:CreatingANode} can generate a tree (Where an element is a Building, Road, Grass or Water). In this project we have used this method from Davis, with a single modification that it is possible to use a binary tree. The main advantage over a binary tree is that it can be easily be made data dependent. It is difficult to determine where the split in a quad tree has to be made. In a binary tree it is a trivial choice, to balance the tree the median is used to split the data.

\begin{algorithm}
\caption{Creating a node}\label{alg:CreatingANode}
\begin{algorithmic}[1]
\Procedure{CreateNode}{$E$}\Comment{E = List with elements}
\If{$\Call{TriangleCount}{E} < max_{Triangles}$}
    \State $\Call{CreateModelData}{E}$
    \State \Return $E$
\Else
    \State $E_{splits}\gets \Call{Split}{E}$ \Comment{Split list in 2 or 4 parts}
    \For{$i \gets 1,n_{splits}$}
        \State $E_{splits}[i] \gets \Call{CreateNode}{E_{splits}[i]}$
        \State $E_{compiledList}.\Call{Add}{E_{splits}[i]}$
    \EndFor
    \State $\Call{SimplifyData}{E_{compiledList}}$
    \State $\Call{CreateModelData}{E_{compiledList}}$
    \State $\Return E_{compiledList}$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

To simplify data the application merges the 2 elements together to get a more simplified version of the original. This merged version is then again added to the list to merge even further. This algorithm is described in \ref{alg:SimplifyData}. The skiplist used in this algorithm is an custom implementation, where deletes can be done in constant time when holding a reference to the specified item. Earlier version of algorithm \ref{alg:SimplifyData}, it was a simpler algorithm, but for every iteration of the while loop it took $O(n^2)$ time. The update function searched every time for the 2 closest elements. We improved this by keeping for every element the closest element and only searched for a new one if the combination between 2 elements is removed. Also in previous version of the algorithm it used when initializing the skiplist a simple linear search to find the closest element. Which makes the the function $InitilizeSkipList$ an $O(n^2)$ algorithm. Later we found a algorithm that can find the nearest neighbor in $O(\log{n})$ time, with an initialization of $O(n\log{n})$ time. So then the function can run in $O(n\log{n})$ time. The whole algorithm was improved from $O(n^2)$ initial and $O(n^2)$ for every iteration too $O(n\log{n})$ initial and $O(n)$ for every iteration.

\begin{algorithm}
\caption{Simplify data}\label{alg:SimplifyData}
\begin{algorithmic}[1]
\Procedure{SimplifyData}{$E$} \Comment{E = List with elements}
\State \Call{RemoveElements}{E}
\State $n_{triangles} \gets \Call{TriangleCount}{}$
\State $Skiplist \gets \Call{Create}{Skiplist}$ \Comment{Skip list with tuple of elements, sorted on distance}
\State $\Call{InitilizeSkipList}{Skiplist, E}$
\While{$n_{triangles} >= max_{Triangles}$}
    \State $combination \gets Skiplist.\Call{ExtractMin}{}$
    \State $n_{triangles} = n_{triangles} - combination.first.n_{triangles}$
    \State $n_{triangles} = n_{triangles} - combination.second.n_{triangles}$
    \State $E_{newElement} = \Call{Merge}{combination.first, combination.second}$
    \State $n_{triangles} = n_{triangles} + E_{newElement}.n_{triangles}$
    \State $\Call{UpdateLists}{Skiplist, E, combination, E_{newElement}}$
\EndWhile
\EndProcedure
\Function{RemoveElements}{$E$}
\For{$i \gets n,1$}
    \If{$E[i].\Call{NeedsToRemove}{}$}
        \State $E.Remove(i)$
    \EndIf
\EndFor
\EndFunction
\Function{InitilizeSkipList}{$Skiplist, E$}
\State $\Call{BuildKDTree}{E}$
\For{$i \gets 1,n$}
    \State $E_{closest} \gets \Call{KDTreeNN}{E[i]}$ \Comment{Find Nearest Neighbor}
    \State $Skiplist.\Call{Add}{Tuple<E[i], E_{closest}>}$
\EndFor
\EndFunction
\Function{UpdateLists}{$Skiplist, E, combination, E_{newElement}$}
\State For every element $E_{references}$ in $E$ that references 1 of $combination$ call $SkipList.\Call{Remove}{E_{references}}$
\State $E_{closest} \gets \Call{FindNN}{E, E_{newElement}}$ \Comment{Find Nearest Neighbor}
\State $Skiplist.\Call{Add}{Tuple<E_{newElement}, E_{closest}>}$
\State $E.\Call{Add}{E_{newElement}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Only models of the same type are merged, so for example only buildings are merged with only buildings. The merge is dependent on the type of the element. Buildings are the only type that can be merged at the moment. They are merged with by taking the convex hull of both buildings.

\subsubsection{Rendering with HLOD}
To addresses the problem what has to be rendered, the node manager is used. The node manager determines which nodes have to be loaded and rendered on screen. This is done by replacing nodes which is currently being used by its children or by its parent. We devised an algorithm that determines which node has to replace which node. By using tree traversal it finds all the maximal nodes which need to be loaded into main memory. This is done by checking whether the error assigned to a node as metadata meets the current distance to that node. If this node has to be loaded, and it isnâ€™t loaded yet, it checks for its entire sub-tree which nodes are currently loaded. For every loaded node in its sub-tree it unloads the nodes. If the current node does not need to be loaded, while it is loaded it will also be unloaded. This way the node manager makes sure all the models will be loaded with the appropriate level of detail. 